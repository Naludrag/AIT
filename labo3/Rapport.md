## AIT Lab 03 - Load balancing

**Author:** Müller Robin, Stéphane Teixeira Carvalho, Massaoudi Walid  
**Date:** 2020-10-07

### Introduction

### Task 1
#### 1.1
When we open the browser the application create a cookie for the user with the server s1 for example.

<img alt="Test 1" src="./imgRapport/1.1_1.PNG" width="700" >

In this screenshot we can see that the session ID NODESESSID is created when we connect to the load balancer.
This token is created by the web apps in our case the web app s1.

When we refresh the page we can see that the NODESESSID changed.
<img alt="Test 1" src="./imgRapport/1.1_2.PNG" width="700" >

This is the case because we changed of web app server, this time it is the web app s2, and so the session created before is unknown to the current server and so a new one is created.

If we continue to refresh the page we will always change of NODESESSID because we will change of server every time and the token in NODESESSID will not be generated by the server contacted

#### 1.2
It should keep the same session id even if the user refresh the page. And for that we should not speak with a different server but with the same that created the session. Because the server that generated the session can validate the token given and so the right session.

#### 1.3
<img alt="Test 1" src="./imgRapport/1.3.PNG" width="700" >

#### 1.4
<img alt="Test 1" src="./imgRapport/1.4.PNG" width="700" >

From the JMeter report we can clearly see that the server is changed on every new request so that means that a round robin is surely implemented.
We can verify that by going to the config files of the load balancer. We can see that the following balancing policy is set : `balance roundrobin`. So it confirms that a round robin is used.
#### 1.5
First here is the result from the JMeter.
<img alt="Test 1" src="./imgRapport/1.5.PNG" width="700" >

If we take a look at the sequence diagram this time we have the following requests :
<img alt="Test 1" src="./imgRapport/1.5_3.PNG" width="700" >

In this case all the requests were sent to the s2 server.
We can also see a different comportement from the session handling :
<img alt="Test 1" src="./imgRapport/1.5_1.PNG" width="700" >
<img alt="Test 1" src="./imgRapport/1.5_2.PNG" width="700" >

This time because we comunicate with the same server we did not change of session id and the sessionView variable incremented as expected.

### Task 2
#### 2.1
The difference between the two ways of implementing the sticky session is mainly the creator of the paramaters. In the first case with the SERVERID the HAProxy will handle it so the id of the server will be added to the response of the server by the proxy to have cover of the track from which server responded.

In the second case with the NODESESSID the HAproxy will use the existing cookie to know to which server send the request. The HAproxy will then have a stick-table per backend node. The advantage of using this approach is that, if we have an application that contains static content that don't need authentification any server will be used to respond to the request.

#### 2.2
We decided to use the NODESESSID already implemented. Here is the configuration :

```bash
cookie NODESESSID prefix nocache
# Define the list of nodes to be in the balancing mechanism
# http://cbonte.github.io/haproxy-dconv/2.2/configuration.html#4-server
server s1 ${WEBAPP_1_IP}:3000 check cookie s1
server s2 ${WEBAPP_2_IP}:3000 check cookie s2
```
In the first line we say that we had a prefix to the cookie named NODESESSID we had the name of the server. So in our case we will see teh prefix s1 or s2.
Then we tell that if we receive a cookie with the prefix s1 we send to the s1 server and if we receive s2 we send to s2.

### Task 3

### Task 4

### Task 5

### Conclusion
